package com.bakdata.conquery.models.preproc.parser.specific;

import javax.validation.constraints.NotEmpty;

import com.bakdata.conquery.models.common.daterange.CDateRange;
import com.bakdata.conquery.models.config.ConqueryConfig;
import com.bakdata.conquery.models.events.stores.primitive.BitSetStore;
import com.bakdata.conquery.models.events.stores.root.DateRangeStore;
import com.bakdata.conquery.models.events.stores.specific.DateRangeTypeCompound;
import com.bakdata.conquery.models.exceptions.ParsingException;
import com.bakdata.conquery.models.preproc.parser.ColumnValues;
import com.bakdata.conquery.models.preproc.parser.Parser;
import io.dropwizard.validation.ValidationMethod;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

/**
 * CompoundDateRangeParser is the Parser of {@link CDateRange} whose start- and end-stores should be saved as references
 * It does not have an implementation logic. It only creates his parser and ignores his input values
 */
@Slf4j
@ToString(callSuper = true)
public class CompoundDateRangeParser extends Parser<Boolean, DateRangeStore> {

	@NotNull
	@NotEmpty
	private final String startColumn, endColumn;


	public CompoundDateRangeParser(ConqueryConfig config, @NotNull String startColumn, @NotNull String endColumn) {
		super(config);
		this.endColumn = endColumn;
		this.startColumn = startColumn;
	}

	@ValidationMethod(message = "Start-Column must be different to End-Column")
	public boolean isStartColumnNotEqualsEndColumn() {
		return !startColumn.equals(endColumn);
	}

	@Override
	public boolean isEmpty() {
		//This ensures that no EmptyStore is generated by this parser if the lines of the parser have not yet been set at that time.
		return false;
	}


	@Override
	protected Boolean parseValue(@NotNull String value) throws ParsingException {
		throw new IllegalStateException("this Parser cannot parse values.");
	}

	@Override
	protected DateRangeStore decideType() {
		return new DateRangeTypeCompound(this.startColumn, this.endColumn, BitSetStore.create(getLines()));
	}


	@Override
	public void setValue(DateRangeStore store, int event, Boolean value) {
		final DateRangeTypeCompound compoundStore = (DateRangeTypeCompound) store;

		compoundStore.setHas(event, value);
	}

	@Override
	public ColumnValues createColumnValues() {
		return new BooleanColumnValues();
	}
}
