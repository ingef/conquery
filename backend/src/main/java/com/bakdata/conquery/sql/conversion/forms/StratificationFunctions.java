package com.bakdata.conquery.sql.conversion.forms;

import static com.bakdata.conquery.sql.conversion.forms.FormConstants.DAY_ALIGNED_COUNT;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.INDEX_START;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.QUARTER_ALIGNED_COUNT;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.QUARTER_END;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.QUARTER_START;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.YEAR_ALIGNED_COUNT;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.YEAR_END;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.YEAR_END_QUARTER_ALIGNED;
import static com.bakdata.conquery.sql.conversion.forms.FormConstants.YEAR_START;
import static com.bakdata.conquery.sql.conversion.forms.Interval.DAYS_PER_QUARTER;
import static com.bakdata.conquery.sql.conversion.forms.Interval.DAYS_PER_YEAR;
import static com.bakdata.conquery.sql.conversion.forms.Interval.MONTHS_PER_QUARTER;

import java.sql.Date;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.bakdata.conquery.apiv1.forms.export_form.ExportForm;
import com.bakdata.conquery.sql.conversion.SharedAliases;
import com.bakdata.conquery.sql.conversion.cqelement.ConversionContext;
import com.bakdata.conquery.sql.conversion.dialect.HanaSqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.dialect.PostgreSqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.dialect.SqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.model.ColumnDateRange;
import com.bakdata.conquery.sql.conversion.model.SqlIdColumns;
import org.jetbrains.annotations.NotNull;
import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.Table;
import org.jooq.impl.DSL;

abstract class StratificationFunctions {

	static StratificationFunctions create(ConversionContext context) {
		SqlFunctionProvider functionProvider = context.getSqlDialect().getFunctionProvider();
		return switch (context.getConfig().getDialect()) {
			case POSTGRESQL -> new PostgresStratificationFunctions((PostgreSqlFunctionProvider) functionProvider);
			case HANA -> new HanaStratificationFunctions((HanaSqlFunctionProvider) functionProvider);
		};
	}

	protected abstract SqlFunctionProvider getFunctionProvider();

	/**
	 * Extract the lower bounds from a given daterange.
	 */
	protected abstract Field<Date> lower(ColumnDateRange dateRange);

	/**
	 * Extract the upper bound from a given daterange.
	 */
	protected abstract Field<Date> upper(ColumnDateRange dateRange);

	/**
	 * Calculates the start and end date based on the given start date and an interval expression.
	 */
	protected abstract ColumnDateRange calcRange(Field<Date> start, Interval interval);

	/**
	 * Extracts the absolute index start date by using the lower bound of the provided date range.
	 */
	public abstract Field<Date> absoluteIndexStartDate(ColumnDateRange dateRange);

	/**
	 * Determines the start of the year based on the lower bound of the provided date range.
	 */
	public abstract Field<Date> yearStart(ColumnDateRange dateRange);

	/**
	 * Determines the start of the next year based on the upper bound of the provided date range.
	 */
	public abstract Field<Date> nextYearStart(ColumnDateRange dateRange);

	/**
	 * Determines the start of the next year based on the upper bound of the provided date range, but aligned on the quarter of the lower bound of the
	 * provided daterange.
	 */
	public abstract Field<Date> yearEndQuarterAligned(ColumnDateRange dateRange);

	/**
	 * Calculates the start of the quarter using the lower bound of the provided date range.
	 */
	public abstract Field<Date> quarterStart(ColumnDateRange dateRange);

	/**
	 * Calculates the start of next quarter of the upper bound of the provided date range.
	 */
	public abstract Field<Date> nextQuartersStart(ColumnDateRange dateRange);

	/**
	 * The int field generated by the {@link #generateIntSeries(int, int)}
	 */
	public abstract Field<Integer> intSeriesField();

	/**
	 * Generates a series of integers from the start value to the exclusive end value.
	 */
	public abstract Table<Record> generateIntSeries(int start, int end);

	/**
	 * Calculates the count of the required resolution windows based on the provided resolution, alignment, and date range.
	 *
	 * @return A {@link Field<Integer>} representing the count of resolution windows.
	 * @throws CombinationNotSupportedException if the combination of resolution and alignment is not supported.
	 */
	public Field<Integer> calculateResolutionWindowCount(ExportForm.ResolutionAndAlignment resolutionAndAlignment, ColumnDateRange bounds) {
		SqlFunctionProvider functionProvider = getFunctionProvider();
		return switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> DSL.field(DSL.val(1));
			case YEARS -> calculateResolutionWindowForYearResolution(resolutionAndAlignment, bounds, functionProvider);
			case QUARTERS -> calculateResolutionWindowForQuarterResolution(resolutionAndAlignment, bounds, functionProvider);
			case DAYS -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
										 .as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
		};
	}

	/**
	 * Determines the stratification range based on resolution and alignment parameters. The created stratification range is bound by the given range.
	 */
	public ColumnDateRange createStratificationRange(ExportForm.ResolutionAndAlignment resolutionAndAlignment, ColumnDateRange bounds) {

		SqlFunctionProvider functionProvider = getFunctionProvider();

		ColumnDateRange stratificationRange = switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> bounds;
			case YEARS -> createStratificationRangeForYearResolution(resolutionAndAlignment);
			case QUARTERS -> createStratificationRangeForQuarterResolution(resolutionAndAlignment);
			case DAYS -> calcRange(INDEX_START, Interval.ONE_DAY_INTERVAL);
		};

		return functionProvider.intersection(stratificationRange, bounds).as(bounds.getAlias());
	}

	/**
	 * The index field for the corresponding resolution index {@link com.bakdata.conquery.ConqueryConstants#CONTEXT_INDEX_INFO}.
	 */
	public Field<Integer> index(SqlIdColumns ids, Optional<ColumnDateRange> stratificationBounds) {

		List<Field<?>> partitioningFields =
				Stream.concat(
							  ids.toFields().stream(),
							  stratificationBounds.stream().flatMap(columnDateRange -> columnDateRange.toFields().stream())
					  )
					  .collect(Collectors.toList());

		return DSL.rowNumber()
				  .over(DSL.partitionBy(partitioningFields))
				  .as(SharedAliases.INDEX.getAlias());
	}

	/**
	 * Generates a condition to limit the resolution window count in a query.
	 * This method applies a check to ensure the series index does not exceed the maximum window count based on the given resolution and alignment.
	 */
	public Condition stopOnMaxResolutionWindowCount(ExportForm.ResolutionAndAlignment resolutionAndAlignment) {
		Field<Integer> seriesIndex = intSeriesField();
		return switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> DSL.noCondition();
			case YEARS -> windowCountForYearResolution(resolutionAndAlignment, seriesIndex);
			case QUARTERS -> windowCountForQuarterResolution(resolutionAndAlignment, seriesIndex);
			case DAYS -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
		};
	}

	private Field<Integer> calculateResolutionWindowForQuarterResolution(
			ExportForm.ResolutionAndAlignment resolutionAndAlignment,
			ColumnDateRange bounds,
			SqlFunctionProvider functionProvider
	) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case QUARTER -> functionProvider.dateDistance(ChronoUnit.MONTHS, QUARTER_START, QUARTER_END)
											.divide(MONTHS_PER_QUARTER)
											.as(SharedAliases.QUARTER_ALIGNED_COUNT.getAlias());
			case DAY -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
										.plus(89)
										.divide(DAYS_PER_QUARTER)
										.as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

	private Field<Integer> calculateResolutionWindowForYearResolution(
			ExportForm.ResolutionAndAlignment resolutionAndAlignment,
			ColumnDateRange bounds,
			SqlFunctionProvider functionProvider
	) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case YEAR -> functionProvider.dateDistance(ChronoUnit.YEARS, YEAR_START, YEAR_END)
										 .as(SharedAliases.YEAR_ALIGNED_COUNT.getAlias());
			case QUARTER -> functionProvider.dateDistance(ChronoUnit.YEARS, QUARTER_START, YEAR_END_QUARTER_ALIGNED)
											.as(SharedAliases.QUARTER_ALIGNED_COUNT.getAlias());
			case DAY -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
										.plus(364)
										.divide(DAYS_PER_YEAR)
										.as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

	private ColumnDateRange createStratificationRangeForQuarterResolution(ExportForm.ResolutionAndAlignment resolutionAndAlignment) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case QUARTER -> calcRange(QUARTER_START, Interval.QUARTER_INTERVAL);
			case DAY -> calcRange(INDEX_START, Interval.NINETY_DAYS_INTERVAL);
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

	private ColumnDateRange createStratificationRangeForYearResolution(ExportForm.ResolutionAndAlignment resolutionAndAlignment) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case YEAR -> calcRange(YEAR_START, Interval.ONE_YEAR_INTERVAL);
			case QUARTER -> calcRange(QUARTER_START, Interval.ONE_YEAR_INTERVAL);
			case DAY -> calcRange(INDEX_START, Interval.YEAR_AS_DAYS_INTERVAL);
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

	private static Condition windowCountForQuarterResolution(ExportForm.ResolutionAndAlignment resolutionAndAlignment, Field<Integer> seriesIndex) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case QUARTER -> seriesIndex.lessOrEqual(QUARTER_ALIGNED_COUNT);
			case DAY -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

	private static Condition windowCountForYearResolution(ExportForm.ResolutionAndAlignment resolutionAndAlignment, Field<Integer> seriesIndex) {
		return switch (resolutionAndAlignment.getAlignment()) {
			case YEAR -> seriesIndex.lessOrEqual(YEAR_ALIGNED_COUNT);
			case QUARTER -> seriesIndex.lessOrEqual(QUARTER_ALIGNED_COUNT);
			case DAY -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
			default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
		};
	}

}
