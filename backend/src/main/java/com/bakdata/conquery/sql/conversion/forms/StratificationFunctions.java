package com.bakdata.conquery.sql.conversion.forms;

import java.sql.Date;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.bakdata.conquery.apiv1.forms.export_form.ExportForm;
import com.bakdata.conquery.sql.conversion.SharedAliases;
import com.bakdata.conquery.sql.conversion.cqelement.ConversionContext;
import com.bakdata.conquery.sql.conversion.dialect.HanaSqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.dialect.PostgreSqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.dialect.SqlFunctionProvider;
import com.bakdata.conquery.sql.conversion.model.ColumnDateRange;
import com.bakdata.conquery.sql.conversion.model.SqlIdColumns;
import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.Table;
import org.jooq.impl.DSL;

abstract class StratificationFunctions {

	protected static int DAYS_PER_YEAR = Interval.YEAR_AS_DAYS_INTERVAL.getAmount();
	protected static int DAYS_PER_QUARTER = Interval.NINETY_DAYS_INTERVAL.getAmount();
	protected static int MONTHS_PER_QUARTER = Interval.QUARTER_INTERVAL.getAmount();

	// field names
	public static Field<Date> INDEX_START = DSL.field(DSL.name(SharedAliases.INDEX_START.getAlias()), Date.class);
	public static Field<Date> QUARTER_START = DSL.field(DSL.name(SharedAliases.QUARTER_START.getAlias()), Date.class);
	public static Field<Date> YEAR_START = DSL.field(DSL.name(SharedAliases.YEAR_START.getAlias()), Date.class);

	public static Field<Integer> YEAR_ALIGNED_COUNT = DSL.field(DSL.name(SharedAliases.YEAR_ALIGNED_COUNT.getAlias()), Integer.class);
	public static Field<Integer> QUARTER_ALIGNED_COUNT = DSL.field(DSL.name(SharedAliases.QUARTER_ALIGNED_COUNT.getAlias()), Integer.class);
	public static Field<Integer> DAY_ALIGNED_COUNT = DSL.field(DSL.name(SharedAliases.DAY_ALIGNED_COUNT.getAlias()), Integer.class);
	public static Field<Integer> SERIES_INDEX = DSL.field(DSL.name(SharedAliases.SERIES_INDEX.getAlias()), Integer.class);

	protected abstract SqlFunctionProvider getFunctionProvider();

	/**
	 * Extract the lower bounds from a given daterange.
	 */
	protected abstract Field<Date> lower(ColumnDateRange dateRange);

	/**
	 * Extract the upper bound from a given daterange.
	 */
	protected abstract Field<Date> upper(ColumnDateRange dateRange);

	/**
	 * Equivalent of a SQL round function.
	 */
	protected abstract Field<Integer> round(Field<? extends Number> number);

	/**
	 * Calculates the start and end date based on the given start date and an interval expression.
	 */
	protected abstract ColumnDateRange calcRange(Field<Date> start, Interval interval);

	/**
	 * Extracts the absolute index start date by using the lower bound of the provided date range.
	 */
	public abstract Field<Date> absoluteIndexStartDate(ColumnDateRange dateRange);

	/**
	 * Determines the start of the year based on the lower bound of the provided date range.
	 */
	public abstract Field<Date> yearStart(ColumnDateRange dateRange);

	/**
	 * Calculates the start of the quarter using the lower bound of the provided date range.
	 */
	public abstract Field<Date> quarterStart(ColumnDateRange dateRange);

	/**
	 * The int field generated by the {@link #generateIntSeries(int, int)}
	 */
	public abstract Field<Integer> intSeriesField();

	/**
	 * Generates a series of integers from the start value to the exclusive end value.
	 */
	public abstract Table<Record> generateIntSeries(int start, int end);

	/**
	 * Calculates the count of the required resolution windows based on the provided resolution, alignment, and date range.
	 *
	 * @return A {@link Field<Integer>} representing the count of resolution windows.
	 * @throws CombinationNotSupportedException if the combination of resolution and alignment is not supported.
	 */
	public Field<Integer> calculateResolutionWindowCount(ExportForm.ResolutionAndAlignment resolutionAndAlignment, ColumnDateRange bounds) {
		SqlFunctionProvider functionProvider = getFunctionProvider();
		return switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> DSL.field(DSL.val(1));
			case YEARS -> switch (resolutionAndAlignment.getAlignment()) {
				case YEAR -> functionProvider.dateDistance(ChronoUnit.YEARS, YEAR_START, upper(bounds))
											 .plus(1)
											 .as(SharedAliases.YEAR_ALIGNED_COUNT.getAlias());
				case QUARTER -> functionProvider.dateDistance(ChronoUnit.YEARS, QUARTER_START, upper(bounds))
												.plus(1)
												.as(SharedAliases.QUARTER_ALIGNED_COUNT.getAlias());
				case DAY -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
											.plus(364)
											.divide(DAYS_PER_YEAR)
											.as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case QUARTERS -> switch (resolutionAndAlignment.getAlignment()) {
				case QUARTER -> round(
						functionProvider.dateDistance(ChronoUnit.MONTHS, QUARTER_START, upper(bounds))
										.plus(2)
										.divide(MONTHS_PER_QUARTER)
				)
						.as(SharedAliases.QUARTER_ALIGNED_COUNT.getAlias());
				case DAY -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
											.plus(89)
											.divide(DAYS_PER_QUARTER)
											.as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case DAYS -> functionProvider.dateDistance(ChronoUnit.DAYS, lower(bounds), upper(bounds))
										 .as(SharedAliases.DAY_ALIGNED_COUNT.getAlias());
		};
	}

	/**
	 * Determines the stratification range based on resolution and alignment parameters. The created stratification range is bound by the given range.
	 */
	public ColumnDateRange createStratificationRange(ExportForm.ResolutionAndAlignment resolutionAndAlignment, ColumnDateRange bounds) {

		SqlFunctionProvider functionProvider = getFunctionProvider();

		ColumnDateRange stratificationRange = switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> bounds;
			case YEARS -> switch (resolutionAndAlignment.getAlignment()) {
				case YEAR -> calcRange(YEAR_START, Interval.ONE_YEAR_INTERVAL);
				case QUARTER -> calcRange(QUARTER_START, Interval.ONE_YEAR_INTERVAL);
				case DAY -> calcRange(INDEX_START, Interval.YEAR_AS_DAYS_INTERVAL);
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case QUARTERS -> switch (resolutionAndAlignment.getAlignment()) {
				case QUARTER -> calcRange(QUARTER_START, Interval.QUARTER_INTERVAL);
				case DAY -> calcRange(INDEX_START, Interval.NINETY_DAYS_INTERVAL);
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case DAYS -> calcRange(INDEX_START, Interval.ONE_DAY_INTERVAL);
		};

		return functionProvider.intersection(stratificationRange, bounds).as(bounds.getAlias());
	}

	/**
	 * The index field for the corresponding resolution index {@link com.bakdata.conquery.ConqueryConstants#CONTEXT_INDEX_INFO}.
	 */
	public Field<Integer> index(SqlIdColumns ids, Optional<ColumnDateRange> validityDate) {

		List<Field<?>> partitioningFields =
				Stream.concat(
							  ids.toFields().stream(),
							  validityDate.stream().flatMap(columnDateRange -> columnDateRange.toFields().stream())
					  )
					  .collect(Collectors.toList());

		return DSL.rowNumber()
				  .over(DSL.partitionBy(partitioningFields))
				  .as(SharedAliases.INDEX.getAlias());
	}

	/**
	 * Generates a condition to limit the resolution window count in a query.
	 * This method applies a check to ensure the series index does not exceed the maximum window count based on the given resolution and alignment.
	 */
	public Condition stopOnMaxResolutionWindowCount(ExportForm.ResolutionAndAlignment resolutionAndAlignment) {
		Field<Integer> seriesIndex = intSeriesField();
		return switch (resolutionAndAlignment.getResolution()) {
			case COMPLETE -> DSL.noCondition();
			case YEARS -> switch (resolutionAndAlignment.getAlignment()) {
				case YEAR -> seriesIndex.lessOrEqual(YEAR_ALIGNED_COUNT);
				case QUARTER -> seriesIndex.lessOrEqual(QUARTER_ALIGNED_COUNT);
				case DAY -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case QUARTERS -> switch (resolutionAndAlignment.getAlignment()) {
				case QUARTER -> seriesIndex.lessOrEqual(QUARTER_ALIGNED_COUNT);
				case DAY -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
				default -> throw new CombinationNotSupportedException(resolutionAndAlignment);
			};
			case DAYS -> seriesIndex.lessOrEqual(DAY_ALIGNED_COUNT);
		};
	}

	static StratificationFunctions create(ConversionContext context) {
		SqlFunctionProvider functionProvider = context.getSqlDialect().getFunctionProvider();
		return switch (context.getConfig().getDialect()) {
			case POSTGRESQL -> new PostgresStratificationFunctions((PostgreSqlFunctionProvider) functionProvider);
			case HANA -> new HanaStratificationFunctions((HanaSqlFunctionProvider) functionProvider);
		};
	}

}
